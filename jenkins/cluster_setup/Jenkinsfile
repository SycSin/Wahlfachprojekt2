pipeline {
    agent any

    parameters {
        choice(
            choices: ['no', 'yes'],
            description: 'Destroy the cluster?',
            name: 'DESTROY'
        )
    }

    stages {
        stage('Destroy & Restore Cluster') {
            when {
                expression { params.DESTROY == 'yes' }
            }
            steps {
                script {
                    def restorePipeline = build job: 'restore_all_nodes'
                    echo "Removing all persistent volumes"
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.210 'rm -r /mnt/ssd/nfs/microk8s/* || true'"
                        }
                    }
                }
	        }
        }
        stage('Register Nodes') {
            when {
                expression { params.DESTROY == 'yes' }
            }
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            echo "Retrieve add node command to execute on node02 and node03"
                            def addNodeCommand = sh(
                                    script: "ssh -o StrictHostKeyChecking=no -i \$SSH_PRIVATE_KEY root@192.168.1.211 '/snap/bin/microk8s add-node | grep \"microk8s join 192.168.1.211\" | head -1'",
                                    returnStdout: true
                            ).trim()
                            echo "Register node02"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.212 '/snap/bin/${addNodeCommand}'"
                            echo "Retrieving new token"
                            addNodeCommand = sh(
                                    script: "ssh -o StrictHostKeyChecking=no -i \$SSH_PRIVATE_KEY root@192.168.1.211 '/snap/bin/microk8s add-node | grep \"microk8s join 192.168.1.211\" | head -1'",
                                    returnStdout: true
                            ).trim()
                            echo "Register node03"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.213 '/snap/bin/${addNodeCommand}'"

                            echo "Verify that High Availability is enabled"
                            def timeoutSeconds = 1800
                            def startTime = currentBuild.startTimeInMillis
                            def endTime = startTime + timeoutSeconds * 1000
                            def haStatus = ""

                            while (System.currentTimeMillis() < endTime) {
                                try {
                                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                                        sshagent(credentials: ['jenkins-private-key']) {
                                            haStatus = sh(returnStdout: true, script: "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s status'").trim()
                                        }
                                    }
                                    echo haStatus
                                    if (haStatus.contains("high-availability: yes")) {
                                        echo "High Availability is enabled."
                                        break
                                    } else {
                                        echo "High Availability is not yet enabled. Retrying in 5 seconds..."
                                        sleep 5
                                    }
                                } catch (Exception e) {
                                    echo "Error checking HA status. Retrying in 5 seconds..."
                                    sleep 5
                                }
                            }
                            if (!haStatus.contains("high-availability: yes")) {
                                error "High Availability was not enabled within the specified timeout."
                            }
                        }
                    }
                }
            }
        }
        stage('Activate NFS-CSI Driver') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            echo "Enabling helm3 addon"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s enable helm3'"
                            echo "Adding csi-driver-nfs helm repository"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s helm3 repo add csi-driver-nfs https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts'"
                            echo "Updating helm repository cache"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s helm3 repo update'"
                            echo "Installing helm chart"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s helm3 upgrade --install csi-driver-nfs csi-driver-nfs/csi-driver-nfs --namespace kube-system --set kubeletDir=/var/snap/microk8s/common/var/lib/kubelet'"
                            echo "Waiting for CSI controller to come up"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl wait pod --selector app.kubernetes.io/name=csi-driver-nfs --for condition=ready --timeout=2700s --namespace kube-system'"
                            echo "Displaying the CSI-Drivers"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl get csidrivers'"
                            echo "Copying the manifests to the node"
                            sh "scp -i ${SSH_PRIVATE_KEY} manifests/*-nfs.yml root@192.168.1.211:/tmp/"
                            echo "Creating the NFS StorageClass"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl apply -f /tmp/sc-nfs.yml'"
                            echo "Creating the Registry Namespace"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl create namespace container-registry || true'"
                            echo "Creating the Registry PVC"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl apply -f /tmp/registry-pvc-nfs.yml'"
                            echo "Removing the manifest files"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 'rm /tmp/*-nfs.yml'"
                        }
                    }
                }
            }
        }
        /*
        stage ('Enable Netdata Monitoring') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            withCredentials([usernamePassword(credentialsId: 'netdata', usernameVariable: 'PARENT_CLAIMING_TOKEN', passwordVariable: 'CHILD_CLAIMING_TOKEN')]) {
                                echo "Adding netdata Helm Repository"
                                sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s helm repo add netdata https://netdata.github.io/helmchart/'"
                                echo "Deploying netdata Helm Chart"
                                sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s helm upgrade --install netdata netdata/netdata --set image.tag=latest --set parent.claiming.enabled=\"true\" --set parent.claiming.token=$PARENT_CLAIMING_TOKEN --set parent.claiming.rooms=1c24b7d3-e2c5-429a-9bf7-bbbf84a4d444 --set child.claiming.enabled=\"true\" --set child.claiming.token=$CHILD_CLAIMING_TOKEN --set child.claiming.rooms=1c24b7d3-e2c5-429a-9bf7-bbbf84a4d444'"
                            }
                        }
                    }
                }
            }
        }
         */
        stage('Enable MicroK8s Addons') {
            steps {
                script {
                    def addons = ['dns', 'registry', 'cert-manager', 'rbac', 'community', 'observability']
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            for (def addon in addons) {
                                echo "Enabling addon: ${addon}"
                                sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s enable ${addon}'"
                            }
                            //TODO: Check if this is really required?
                            //echo "Restarting MicroK8s"
                            //sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s stop && /snap/bin/microk8s start'"
                        }
                    }
                }
            }
        }
        stage('Install ArgoCD') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            echo "Creating namespace 'argocd'"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl create namespace argocd || true'"
                            echo "Installing ArgoCD manifest"
                            sh "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 '/snap/bin/microk8s kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml'"
                        }
                    }
                }
            }
        }
        stage('Readiness probe') {
            steps {
                script {
                    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-private-key', keyFileVariable: 'SSH_PRIVATE_KEY')]) {
                        sshagent(credentials: ['jenkins-private-key']) {
                            def namespaces = sh(
                                    returnStdout: true,
                                    script: "ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 'snap/bin/microk8s kubectl get namespaces -o=jsonpath=\"{range .items[*]}{.metadata.name}{\"\\n\"}{end}\"'"
                            ).trim()
                            sh """
                                #!/bin/bash
                                for ns in $namespaces; do
                                    echo "Waiting for pods to be ready in namespace: $ns"
                                    ssh -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY} root@192.168.1.211 \"/snap/bin/microk8s kubectl wait --for=condition=ready pod --all -n $ns\"
                                done
                            """
                            echo "All pods are ready."
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def title = "Pipeline Status: ${currentBuild.result}"
                def message
                
                withCredentials([usernamePassword(credentialsId: 'pushover', usernameVariable: 'PUSHOVER_USER_KEY', passwordVariable: 'PUSHOVER_API_TOKEN')]) {
                    if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                        message = "Cluster successfully installed: ${currentBuild.fullDisplayName}"
                    } else {
                        message = "Cluster installation failed: ${currentBuild.fullDisplayName}"
                    }
                    
                    // Pushover API URL
                    def pushoverUrl = "https://api.pushover.net/1/messages.json"
                    
                    sh "curl -s -F 'token=$PUSHOVER_API_TOKEN' -F 'user=$PUSHOVER_USER_KEY' -F 'message=$message' -F 'title=$title' $pushoverUrl"
                }
            }
        }
    }
}
